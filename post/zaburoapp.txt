AUTHOR: ZABURO
TITLE: ブログ作りました。
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: お知らせなど
CATEGORY: お知らせなど

DATE: 11/06/2013 20:21:01
-----
BODY:
つくったゲームをGoogle playで公開するにあたり、
自分が情報を発信する場所を持っておこうという事で、
ウェブサイト代わりにブログ作りました。

アプリの詳細やメモ的なことを残していくつもりです。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: Don't touch the wall【ver1.1公開】
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: Androidアプリ
CATEGORY: Androidアプリ

DATE: 11/06/2013 20:55:34
-----
BODY:
<a href="http://zaburoapp.blog.fc2.com/img/icon_ad.png/" target="_blank"><img src="http://blog-imgs-62.fc2.com/z/a/b/zaburoapp/icon_ad.png" alt="icon_ad.png" border="0" width="400" height="195" /></a>

画面を傾けてゴールを目指せ！
本格難易度のイライラ棒風ゲーム。

壁や障害物をかわしてゴールにたどり着けばクリア。
全６ステージを全てクリアすれば、
EXTRAステージで遊べます！

操作するポインターは重さがないため
繊細な操作のサクサク感と
敏感すぎる動きのイライラ感が
体感できる作りになっています。
イライラとクリア時の達成感をお楽しみください！

↓ダウンロードはこちら！
<a href="https://play.google.com/store/apps/details?id=jp.gr.java_conf.kchubachi.iraira" target="_blank"><img src="http://blog-imgs-62.fc2.com/z/a/b/zaburoapp/icon_high.png" alt="icon_high.png" border="0" width="120" height="120" /></a>

スクリーンショット
（画像は開発中のものです）
<a href="http://zaburoapp.blog.fc2.com/img/ss01.png/" target="_blank"><img src="http://blog-imgs-62.fc2.com/z/a/b/zaburoapp/ss01.png" alt="ss01.png" border="0" width="400" height="240" /></a>

<a href="http://zaburoapp.blog.fc2.com/img/ss02.png/" target="_blank"><img src="http://blog-imgs-62.fc2.com/z/a/b/zaburoapp/ss02.png" alt="ss02.png" border="0" width="400" height="240" /></a>

<a href="http://zaburoapp.blog.fc2.com/img/ss03.png/" target="_blank"><img src="http://blog-imgs-62.fc2.com/z/a/b/zaburoapp/ss03.png" alt="ss03.png" border="0" width="400" height="240" /></a>


音楽等の素材の一部を
下記サイト様からお借りしています。
魔王魂
http://maoudamashii.jokersounds.com/
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【AndEngine】onPauseでNullPointerException
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: AndEngine
CATEGORY: AndEngine

DATE: 11/17/2013 18:13:44
-----
BODY:
一部機種において(Androidのバージョンの問題？)
起動直後に強制終了してしまうバグに悩まされたのでメモ。

logcatでシステムのログを確認すると
SimpleLayoutGameActivityを継承しているMainActivityが
謎の挙動をしている模様。

onCreate,onResumeの後になぜかonPauseが呼び出され
NullPointerExceptionで強制終了していました。

MainActivityのメンバとして以下を定義し
<blockquote><p>private boolean isGoing = false;</p></blockquote>onPauseの処理をisGoingがtrueのときにしかしないように
ifで指定してやることで解決。
onCreateSceneでisGoingをtrueにしてます。

onResumeの後にonPauseが呼ばれるなんて
ライフサイクル無視しすぎやん！ってすごく困ったんですが、
どうやらonResumeあたりでエラーが発生して
AndEngineがアプリを再起動しようとした結果
onPauseが呼ばれていたみたいです。
で、onCreateSceneあたりで生成する予定のオブジェクトは
ここでonPauseが呼ばれたときにはまだ生成されていないので
それらのオブジェクトを操作する処理がonPauseにかかれていると
NullPointerExceptionで落ちるというわけでした。

ちなみにそのエラーには以下のようなコメントがついていて
<blockquote><p>UpdateThread interrupted. Don't worry - this EngineDestroyedException is most likely expected!</p></blockquote>UpdateThreadが中断されちゃったよ！
まあこのEngineが落ちちゃう例外はよくあることだから安心して！
ってなわけなのでどうやらAndEngine側に問題がある模様。

Forumなどを探して見たところ
ソースはありませんでしたが「99.999%そのエラーは起きるよ」
というコメントがあるほどで私の技術力では何ともしがたい問題のようです。
なんだかなー
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AndroidのSQLiteで部分一致している文字列を検索
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 12/12/2013 16:32:38
-----
BODY:
AndroidでSQLiteを使うようなアプリを作成していて、
「Android SQLite」でぐぐっても
基本的な「検索」「挿入」「更新」「削除」あたりの
ざっくりした方法しか見つけられないので、
補足的な感じで、部分一致している文字列の検索とか
検索条件の詳しい書き方の調べ方をメモっておきます。

どうにも改行が下手です。
<strong>
【部分一致している文字列の検索】</strong>
SQLで言う(SQL分からないけど)「LIKE句」と
ワイルドカードである「%」を使うらしいです。
たとえば、
<blockquote><p>cursor = mydb.query("my_table", null, "name like ?", new String[]{"%"+ "検索対象文字列" +"%"}, null, null, null);</p></blockquote>ってしてやると、
nameっていうフィールドにある各文字列から
「検索対象文字列」を含む文字列を検索してくれる。
<span style="font-size:x-small;">mydbっていうのはSQLiteDatabaseのインスタンスで
my_tableはテーブル名。</span>

<strong>【検索条件の詳しい書き方の調べ方】</strong>
SQLiteってAndroidに独特なものではないから、
素直に「SQLite」でぐぐる。もしくは「SQL」。
すると
<blockquote><p>select * from customer where address = '東京';</p></blockquote>って感じの全然文法の違う文がでてくるけど、この検索条件はAndroid版の
<blockquote><p>cursor = mydb.query("customer", null, "address = ?", new String[]{"東京"}, null, null, null);</p></blockquote>と大体同じ意味。
というのも、内部での動作なんて調べてないから分からないけど、
たぶん、mydb.queryってしたときAndroid側で
<blockquote><p>select 第2引数 from 第1引数 where 第3引数と第4引数</p></blockquote>という文を作ってSQLite側に投げてくれてるってイメージでいいと思います。
（第3引数の?に第4変数で指定した文字列の配列から順に文字列が入ります）
<span style="font-size:x-small;">（Cのprintfに近いものを感じた……）</span>
第5引数とかも指定すればgroup by句とかとして文に入ってくるはず。
それがわかってれば、
<a href="http://www.dbonline.jp/sqlite/select/" target="_blank" title="sqlite"><u>http://www.dbonline.jp/sqlite/select/</u></a>
こういうSQLiteの解説サイトを読み替えできるので
欲しい情報は得やすくなると思います。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【Android】NDK から OpenCV を使うプロジェクトを作る手順
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 01/06/2014 23:37:13
-----
BODY:
久しぶりにAndroidでOpenCVを使おうとしたら
書き始めるまでに必要な準備を忘れていたのでメモ。
コメントを書き入れている部分は
「ここにかかなければいけない、というわけではないけど
ここに書いておくのが便利」という部分です

環境 Eclipse 3.7.2

・「プロパティ」→「Android」からOpenCVのライブラリを登録

・OpenCVを使うActivityのメンバに以下を追加し
<pre class="brush:java" title="">private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {
    @Override
    public void onManagerConnected(int status) {
        switch (status) {
        case LoaderCallbackInterface.SUCCESS:
            //ここで後で自分で作成するC/C++でopencvを動かすライブラリをロードしておく
            System.loadLibrary("my_opencv_method");
            //ロードが成功した場合にのみボタンを有効にする
            mButton.setEnabled(true);
            break;
        default:
            super.onManagerConnected(status);
            break;
        }
    }
};</pre>onResumeを以下のようにオーバーライド
<pre class="brush:java" title="">@Override
public void onResume()
{
    super.onResume();
    //ボタンはロード成功するまでは無効化しておく
    mButton1.setEnabled(false);
    OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_2_4_3, this, mLoaderCallback);
}</pre>
・プロジェクトを右クリック→「Android ツール」→「Add native support」

・プロジェクトを右クリック→「プロパティ」→「C/C++一般」→「パスおよびシンボル」→「インクルード」タブ→「追加」ボタン
で最低でも以下の３つを登録
/opt/OpenCV-2.4.6-android-sdk/sdk/native/jni/include
/opt/android-ndk-r9/sources/cxx-stl/gnu-libstdc++/4.6/include
/opt/android-ndk-r9/sources/cxx-stl/gnu-libstdc++/4.6/libs/armeabi-v7a/include
(僕は/optに各ライブラリを置いているのでそのへんは適宜修正)

・jniフォルダを作成して、Android.mkとApplication.mkを用意
(他のプロジェクトからコピペして編集)
Android.mk
<pre class="brush:cpp" title="">LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

#OPENCV_CAMERA_MODULES:=off
#OPENCV_INSTALL_MODULES:=off
#OPENCV_LIB_TYPE:=SHARED
include /opt/OpenCV-2.4.6-android-sdk/sdk/native/jni/OpenCV.mk

LOCAL_SRC_FILES  := my_opencv_method.cpp
LOCAL_C_INCLUDES += $(LOCAL_PATH)
LOCAL_LDLIBS     += -llog -ldl

LOCAL_MODULE     := my_opencv_method

include $(BUILD_SHARED_LIBRARY)
</pre>
Application.mk
<pre class="brush:cpp" title="">APP_STL := gnustl_static
APP_CPPFLAGS := -frtti -fexceptions
APP_ABI := armeabi-v7a
APP_PLATFORM := android-8</pre>
・Activityにnativeメソッドを記載
例
<pre class="brush:cpp">public static native void threshold(long matAddr);
public static native int[] findContours(long matAddr);</pre>
・プロジェクトのAndroidManifest.xmlなどが保存してあるディレクトリに移動し以下のコマンドを実行
<pre class="brush:java">javah -classpath src -o jni/my_opencv_method.h {package name}.MainActivity</pre>jniにmy_opencv_method.hが生成される

・my_opencv_method.hからメソッドをコピー
<pre class="brush:cpp">JNIEXPORT void JNICALL Java_com_fc2_blog_zaburoapp_markerdetection_MainActivity_threshold (JNIEnv *, jclass, jlong);</pre>

・my_opencv_method.cppを作成してペーストし、以下のincludeを加える
<pre class="brush:cpp">#include &lt;jni.h&gt;
#include &lt;vector&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/objdetect/objdetect.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/calib3d/calib3d.hpp&gt;
#include &lt;android/log.h&gt;
#include &lt;my_opencv_method.h&gt;</pre>このへんがあれば十分
(JNIEnv *, jclass, jlong)→(JNIEnv * jenv, jclass, jlong matAddr)みたいな感じで
変数名を指定するのを忘れずに。

・コードを書いて実行
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AndroidとNXTをBluetoothで接続
STATUS: Draft
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: 未分類
CATEGORY: 未分類

DATE: 01/31/2014 18:07:39
-----
BODY:
MINDdroidのソースをダウンロードしてくる

・ソースフォルダ
BTCommunicator.java
BTConnectable.java
DeviceListActivity.java
LCPMessage.java
・/res/layout
device_list.xml
device_name.xml
・/res/value
string.xml
をコピー
ソースファイルのパッケージ名とか
string.xmlのapp_nameとかは適宜修正

Bluetoothで通信を行う(1) &laquo;  Tech Booster
<a href="http://techbooster.jpn.org/andriod/application/5191/" target="_blank" title="Bluetoothで通信を行う(1) Tech Booster">http://techbooster.jpn.org/andriod/application/5191/</a>
でアプリケーションの起動〜Bluetoothの設定をONにするまでを実装

<pre class="brush:xml">&lt;activity
  android:name="パッケージ名.DeviceListActivity"
  android:label="@string/select_device"
  android:theme="@android:style/Theme.Dialog" /&gt;</pre>
以下のメソッドを実装
startNXTどうのこうの
<span style="color:#FF0000">ーーーーーーーーーーーーーーーあとでかく</span>

<pre class="brush:java">if(btEnable == true){
    //ここ
}else{
     Intent btOn = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
     startActivityForResult(btOn, REQUEST_ENABLE_BLUETOOTH);
}</pre>と
<pre class="brush:java">if(ResultCode == Activity.RESULT_OK){
    Log("BluetoothをONにしてもらえました。");
    //ここ
}</pre>で実行
<pre class="brush:java">if(requestCode == REQUEST_ENABLE_BLUETOOTH){
中略
}else if(requestCode == DEVICE_LIST_ACTIVITY){
<span style="color:#FF0000">ーーーーーーあとでかく</span>
}</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【Android】BitmapのgetPixels()について
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 02/02/2014 14:09:21
-----
BODY:
分かりやすく解説しているページがあったのでメモ

<strong>しずくくんのAndroidでゲームプログラミングしてみたいなblog</strong>
Bitmap.getPixels()のstride引数の意味がわかった
<a href="http://blog.livedoor.jp/shizuku_kun/archives/51385763.html" target="_blank" title="Bitmap.getPixels()のstride引数の意味がわかった">http://blog.livedoor.jp/shizuku_kun/archives/51385763.html</a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: OpenCV for Android で特定の色を抽出 (NDK)
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 02/02/2014 22:50:06
-----
BODY:
書きました。

・ネイティブメソッドの記述
<pre class="brush:java">//色抽出
public static native void colorExtract(long matAddr,int code,
										int lowH,int highH,
										int lowS,int highS,
										int lowV,int highV);</pre>
・ネイティブコード
<pre class="brush:cpp">JNIEXPORT void JNICALL Java_com_fc2_blog_zaburoapp_markerdetection_MainActivity_colorExtract
  (JNIEnv * jenv, jclass, jlong matAddr, jint code, jint lowH, jint highH, jint lowS, jint highS, jint lowV, jint highV){

	Mat *inputImg;
	inputImg = (Mat*) matAddr;

	int height = inputImg->rows;
	int width = inputImg->cols;

	Mat hsvImg = Mat(height,width,CV_8UC3);
	cvtColor(*inputImg,hsvImg,code);

	vector<Mat> singleCh;
	split(hsvImg,singleCh);

	Mat h1,h2,h,s1,s2,s,v1,v2,v,hs,mask;
	if(lowH<=highH){
		threshold((Mat)singleCh[0],h1,lowH,255,CV_THRESH_BINARY);
		threshold((Mat)singleCh[0],h2,highH,255,CV_THRESH_BINARY_INV);
		bitwise_and(h1,h2,h);
	}else{
		threshold((Mat)singleCh[0],h1,lowH,255,CV_THRESH_BINARY);
		threshold((Mat)singleCh[0],h2,highH,255,CV_THRESH_BINARY_INV);
		bitwise_or(h1,h2,h);
	}
	if(lowS<=highS){
		threshold((Mat)singleCh[1],s1,lowS,255,CV_THRESH_BINARY);
		threshold((Mat)singleCh[1],s2,highS,255,CV_THRESH_BINARY_INV);
		bitwise_and(s1,s2,s);
	}else{
		threshold((Mat)singleCh[1],s1,lowS,255,CV_THRESH_BINARY);
		threshold((Mat)singleCh[1],s2,highS,255,CV_THRESH_BINARY_INV);
		bitwise_or(s1,s2,s);
	}
	if(lowH<=highH){
		threshold((Mat)singleCh[2],v1,lowV,255,CV_THRESH_BINARY);
		threshold((Mat)singleCh[2],v2,highV,255,CV_THRESH_BINARY_INV);
		bitwise_and(v1,v2,v);
	}else{
		threshold((Mat)singleCh[2],v1,lowV,255,CV_THRESH_BINARY);
		threshold((Mat)singleCh[2],v2,highV,255,CV_THRESH_BINARY_INV);
		bitwise_or(v1,v2,v);
	}

	bitwise_and(h,s,hs);
	bitwise_and(hs,v,mask);

	Mat dstImg = Mat(height,width,inputImg->type(),Scalar(0,0,0));
	inputImg->copyTo(dstImg,mask);
	dstImg.copyTo(*inputImg);

}</pre>
・使い方・例
<pre class="brush:java">Mat matImg = new Mat();
Utils.bitmapToMat(bmp,matImg);
colorExtract(matImg.getNativeObjAddr(),Imgproc.COLOR_RGB2HSV,
			170,10,
			80,255,
			0,255);
Utils.matToBitmap(matImg, bmp);
mImageView.setImageBitmap(bmp);</pre>って感じで使えば
色相(H)：0〜10,170〜255
彩度(S)：80〜255
明度(V)：0〜255
の範囲の色を入力画像と同じサイズの黒背景の画像に抽出します。
第２引数のcodeはBitmapは大抵RGBのイメージだから
こんな感じにしとけば概ね間違いないと思います。
内部で、CV_8UC3(符号無し8bit整数3チャンネル)で画素を扱う都合上
色のパラメータは0〜255の範囲で表現します。
たぶん範囲外の値を渡すと落ちます。
例外投げる部分かけばよかったんですけど、めんどうでした。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: うまかったコレクション【ver1.0】
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: Androidアプリ
CATEGORY: Androidアプリ

DATE: 03/03/2014 13:26:03
-----
BODY:
<a href="http://zaburoapp.blog.fc2.com/img/opening.png/" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/opening.png" alt="opening.png" border="0" width="390" height="220" /></a>

レシピ・外食のメモアプリ

うまかったレシピや外食を
このアプリにメモしてコレクションしましょう！

★クックパッドのレシピを保存・メモする機能あり★

ダウンロードはこちら↓
<a href="https://play.google.com/store/apps/details?id=com.fc2.blog.zaburoapp.mayrecipebook" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/umacolle_icon_high.png" alt="umacolle_icon_high.png" border="0" width="128" height="128" /></a>


■こんな方に
・前においしく作れた料理の味を再現できない！
・「ここら辺に良い店ない？」にパッと答えられない！
・普通のメモアプリは入力が面倒、見づらい！
・レシピサイトに当たり外れが多すぎる！

■アプリ概要
あなたが実際に食べて「うまかった」と思えた料理を集めていくアプリです。
誰かがうまいと言った料理を集めるアプリではありません。

「うまかった」と思える料理を作れたら
「レシピを登録」でレシピをメモしましょう。
事細かく全部書く必要はありません。
忘れてしまいそうなポイントだけをメモして、
面倒な項目なんてとばしてしまいましょう。
誰が見ても分かるレシピをつくるアプリではありません。
あなたがレシピを思い出すためのメモを作るアプリです。

「うまかった」と思える外食を食べたら
「外食を登録」で外食をメモしましょう。
場所・感想など次にいくときのヒントをメモします。
位置情報ネットワークかGPSを使えば
アプリが自動で現在地の住所を入力してくれます。

そして、
レシピ・外食を思い出すとき、また
うまかったもののコレクションをみたくなったときに
このアプリを起動します。
「一覧」「検索」「カテゴリ表示」などの機能を使えば
あなたが見つけたいメモは簡単に見つかります！

■解像度・文字サイズによらないつくり
文字が小さくなってしまって見づらい
ということはありえません！
機種やそれぞれの端末ごとに様々な
解像度・文字サイズによらず
どの端末でも同様の見た目で
レシピを見たり登録したりすることができます。

■馴染みのあるデザイン
このアプリのUIのデザインは
あなたが普段使っているアプリと同様の
直感的操作ができるようになっています。
新しく使い方を覚えることは限りなく少ないです。

■レシピアプリとしての機能
画像やWebへのリンクが使えることはもちろん、
マップとの連携や検索・編集・削除など
一般的なレシピアプリとしての機能も充実しています。


スクリーンショット
<a href="http://zaburoapp.blog.fc2.com/img/umacolle_ss_1.png/" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/umacolle_ss_1.png" alt="umacolle_ss_1.png" border="0" width="120" height="190" /></a> <a href="http://zaburoapp.blog.fc2.com/img/umacolle_ss_5.png/" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/umacolle_ss_5.png" alt="umacolle_ss_5.png" border="0" width="120" height="190" /></a>
<a href="http://zaburoapp.blog.fc2.com/img/umacolle_ss_6.png/" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/umacolle_ss_6.png" alt="umacolle_ss_6.png" border="0" width="120" height="190" /></a> <a href="http://zaburoapp.blog.fc2.com/img/umacolle_ss_3.png/" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/umacolle_ss_3.png" alt="umacolle_ss_3.png" border="0" width="120" height="190" /></a>
<a href="http://zaburoapp.blog.fc2.com/img/umacolle_ss_4.jpg/" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/umacolle_ss_4.jpg" alt="umacolle_ss_4.jpg" border="0" width="250" height="187" /></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: Digitalarts Programming Contest 2013
STATUS: Draft
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: お知らせなど
CATEGORY: お知らせなど

DATE: 03/05/2014 16:33:08
-----
BODY:
デジタルアーツ様が開催されている
「Digitalarts Programming Contest 2013」に
先日公開した「うまかったコレクション」で参加し
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【修正】うまかったコレクション【ver1.1】
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: Androidアプリ
CATEGORY: Androidアプリ

DATE: 04/02/2014 17:27:04
-----
BODY:
先月公開したうまかったコレクションについて
機種によって、高画質なカメラでとった画像など
大きなサイズの写真を開いたとき
メモリ不足でアプリが終了してしまっていたので
修正させて頂きました。

バグレポートを送ってくださった方、ありがとうございます。


ダウンロードはこちら↓
<a href="https://play.google.com/store/apps/details?id=com.fc2.blog.zaburoapp.mayrecipebook" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/umacolle_icon_high.png" alt="umacolle_icon_high.png" border="0" width="128" height="128" /></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【機能追加】うまかったコレクション【ver2.0】
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: Androidアプリ
CATEGORY: Androidアプリ

DATE: 04/21/2014 00:30:40
-----
BODY:
リリースから１ヶ月が経過し
皆様にご愛護頂いているうまかったコレクションですが、
「写真を複数登録できるようにしてほしい」
というご要望が寄せられたため
今回のアップデートで対応させて頂きました。

ご要望につきましては、
zaburo.appあっとgmail.com
までメール頂ければ可能な限り対応させて頂きます。

これからもよろしくお願いいたします。

【変更点】
・写真を複数登録できるようにしました。
・「No Image」の部分を「No Thumbnail」に変更しました。


ダウンロードはこちら↓
<a href="https://play.google.com/store/apps/details?id=com.fc2.blog.zaburoapp.mayrecipebook" target="_blank"><img src="http://blog-imgs-66.fc2.com/z/a/b/zaburoapp/umacolle_icon_high.png" alt="umacolle_icon_high.png" border="0" width="128" height="128" /></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 蟻本やってます
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: お知らせなど
CATEGORY: お知らせなど

DATE: 06/24/2014 17:44:49
-----
BODY:
７月にあるICPC国内予選に向けて蟻本を解いています。
せっかく書いたソースコードをそのままにしておくのももったいないので
ここにガシガシ載っけていこうかなと思います。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AOJ 0033 Ball
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: icpc_practice
CATEGORY: icpc_practice

DATE: 06/24/2014 17:54:02
-----
BODY:
初めて書いた(?)深さ優先探索
条件がかなり緩いので全探索可能

<pre class="brush:cpp">int n;
int ba[10];

bool all(int,int,int);

int main(){
  cin >> n;
  for(int i=0;i<n;i++){
    for(int j=0;j<10;j++){
      cin >> ba[j];
    }
    if(all(0,0,0)){
      cout << "YES" << endl;
    }else{
      cout << "NO" << endl;
    }
  }
}

bool all(int end,int l,int r){
  if(end==10){
    return true;
  }
  if(ba[end]>l){
    return all(end+1,ba[end],r);
  }
  if(ba[end]>r){
    return all(end+1,l,ba[end]);
  }
  return false;
}


</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AOJ 0121 Seven Puzzle
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: icpc_practice
CATEGORY: icpc_practice

DATE: 06/24/2014 18:11:41
-----
BODY:
幅優先探索の問題
まず考えたのは、初期状態から0をどんどん移動させて行く方法。
パズルの状態はstringで表現している。
mapで状態とそこまでの最短距離を対応させ、
mapに存在するかどうかでたどり着いたことがあるかを確認。
ただ、これだとTLEをくらう。
<pre class="brush:cpp">
//TLEをくらうコード

void swap(char *a,char *b){
  char temp = *a;
  *a = *b;
  *b = temp;
}

int main(){
  int dx[] = {+1,-1,+4,-4};
  while(1){
    string input = "";
    char temp;
    for(int i=0;i<8;i++){
      if(cin >> temp){
        input.push_back(temp);
      }else{
        return 0;
      }
    }

    queue<string> que;
    map<string,int> d;
    que.push(input);
    d[input] = 0;

    while(que.size()){
      string q = que.front(); que.pop();
      if(q=="01234567"){
        break;
      }
      int x = q.find("0");
      for(int i=0;i<4;i++){
        int next = x + dx[i];
        if( next>=0 && next<=7 && !(x==3&&next==4) && !(x==4&&next==3) ){
          string nextq = q;
          swap(&nextq[x],&nextq[next]);
          if(d.find(nextq)==d.end()){
            que.push(nextq);
            d[nextq] = d[q] + 1;
          }
        }
      }
    }
    cout << d["01234567"] << endl;
  }
}


</pre>
inputは１０００個まで与えられるので、
毎回一から探索していっているのでは無駄が多い。
そもそも、ありえる状態は8!通りしかないから
そろった状態からたどりつけるすべての状態への最短距離を計算しておき
inputに対応した最短距離を出力するほうがいい。
同じようにmapを使って状態と最短距離を対応させる。

<pre class="brush:cpp">
//通ったコード

void swap(char *a,char *b){
  char temp = *a;
  *a = *b;
  *b = temp;
}

int main(){
  int dx[] = {+1,-1,+4,-4};

  string start = "01234567";

  queue<string> que;
  map<string,int> d;
  que.push(start);
  d[start] = 0;

  while(que.size()){
    string q = que.front(); que.pop();
    int x = q.find("0");
    for(int i=0;i<4;i++){
      int next = x + dx[i];
      if( next>=0 && next<=7 && !(x==3&&next==4) && !(x==4&&next==3) ){
        string nextq = q;
        swap(&nextq[x],&nextq[next]);
        if(d.find(nextq)==d.end()){
          que.push(nextq);
          d[nextq] = d[q] + 1;
        }
      }
    }
  }

  while(1){
    string input = "";
    char temp;
    for(int i=0;i<8;i++){
      if(cin >> temp){
        input.push_back(temp);
      }else{
        return 0;
      }
    }
    cout << d[input] << endl;
  }

}


</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AOJ 0525 Osenbei
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: icpc_practice
CATEGORY: icpc_practice

DATE: 06/24/2014 18:30:38
-----
BODY:
0の個数を最大にするとき、どの行をひっくり返すか決めると
ひっくり返すべき列とそれで得られる0の個数が一意的に決まる。
Rが十分に小さいので行のひっくり返し方を全通り試し
そのひっくり返し方に対応する0の個数の最大を出力する。
行のひっくり返し方を再帰で書くとこんな感じ
<pre class="brush:cpp">
int senbei[10][10000];
int r,c;
int rowFlag[10];
int Max;
 
void countSum(){
  int sum=0;
  for(int i=0;i<c;i++){
    int colSum = 0;
    for(int j=0;j<r;j++){
      if(senbei[j][i]==!rowFlag[j]){
        colSum++;
      }
    }
    sum += max(colSum,r-colSum);
  }
  if(Max<sum){
    Max = sum;
  }
}
 
void setFlag(int pos){
  if(pos==r){
    countSum();
    return;
  }
  rowFlag[pos] = 1;
  setFlag(pos+1);
 
  rowFlag[pos] = 0;
  setFlag(pos+1);
}
 
int main(){
  while(1){
    cin >> r >> c;
    if(r==0&&c==0) return 0;
    for(int i=0;i<r;i++){
      for(int j=0;j<c;j++){
        cin >> senbei[i][j];
      }
    }
    Max = 0;
    setFlag(0);
    cout << Max << endl;
  }
}


</pre>

再帰を使わないで蟻本っぽく解くならこんな感じ？
通ったから一応あってると思う。
<pre class="brush:cpp">

int senbei[10][10000];
int r,c;
int rowFlag[10];
int Max;

int countSum(){
  int sum=0;
  for(int i=0;i<c;i++){
    int colSum = 0;
    for(int j=0;j<r;j++){
      if(senbei[j][i]==!rowFlag[j]){
        colSum++;
      }
    }
    sum += max(colSum,r-colSum);
  }
  return sum;
}

int main(){
  while(1){
    cin >> r >> c;
    if(r==0&&c==0) return 0;
    for(int i=0;i<r;i++){
      for(int j=0;j<c;j++){
        cin >> senbei[i][j];
      }
    }
    Max = 0;
    for(int i=0;i<1<<r;i++){
      for(int j=0;j<r;j++){
        rowFlag[j] = i >> j & 1;
      }
      int sum = countSum();
      if(Max<sum){
        Max = sum;
      }
    }
    cout << Max << endl;
  }
}


</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AOJ 0118 Property Distribution
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: icpc_practice
CATEGORY: icpc_practice

DATE: 06/24/2014 18:40:44
-----
BODY:
蟻本に載ってたPOJ2386とだいたい同じ。
同じグループを消してく。
<pre class="brush:cpp">
int H,W;
char map[100][100];
 
void grouping(int h,int w,char f);
 
int main(){
  while(1){
    cin >> H >> W;
    if(H==0&&W==0)break;
 
    for(int i=0;i<H;i++){
      for(int j=0;j<W;j++){
        cin >> map[i][j];
      }
    }
    int x=0;
    for(int i=0;i<H;i++){
      for(int j=0;j<W;j++){
        if(map[i][j]!='.'){
          x++;
          grouping(i,j,map[i][j]);
        }
      }
    }
    cout << x << endl;
  }
}
 
void grouping(int h,int w,char f){
  map[h][w] = '.';
  if(h-1>=0&&map[h-1][w]==f){
    grouping(h-1,w,f);
  }
  if(h+1<H&&map[h+1][w]==f){
    grouping(h+1,w,f);
  }
  if(w-1>=0&&map[h][w-1]==f){
    grouping(h,w-1,f);
  }
  if(w+1<W&&map[h][w+1]==f){
    grouping(h,w+1,f);
  }
}


</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AOJ 0189 Convenient Location
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: icpc_practice
CATEGORY: icpc_practice

DATE: 07/02/2014 22:34:19
-----
BODY:
全点最短路問題です。
ワーシャル・フロイド法を用いて解きます。
cost[i][i]を0にするのをお忘れなく！

<pre class="brush:cpp">
int cost[10][10];
int n,m;

int main(){
  while(1){
    cin >> n;
    if(!n)break;

    m = 0;
    for(int i=0;i<10;i++){
      for(int j=0;j<10;j++){
        if(i==j){
          cost[i][j] = 0;
        }else{
          cost[i][j] = INF;
        }
      }
    }
    for(int i=0;i<n;i++){
      int x,y,z;
      scanf("%d%d%d",&x,&y,&z);
      if(m<x||m<y){
        m = max(x,y);
      }
      cost[x][y] = z;
      cost[y][x] = z;
    }
    m++;

    for(int k=0;k<m;k++){
      for(int i=0;i<m;i++){
        for(int j=0;j<m;j++){
          cost[i][j] = min(cost[i][j],cost[i][k]+cost[k][j]);
        }
      }
    }

    /*for(int i=0;i<m;i++){
      for(int j=0;j<m;j++){
        printf("%d%c",cost[i][j],j==m-1?'\n':' ');
      }
    }*/

    int mini = INF;
    int index;
    for(int i=0;i<m;i++){
      int sum = 0;
      for(int j=0;j<m;j++){
        sum += cost[i][j];
      }
      if(mini>sum){
        mini = sum;
        index = i;
      }
    }
    cout << index << " " << mini << endl;
  }
}


</pre>
町の総数が10以下と十分に小さく、負の辺がないため
ひとつずつダイクストラ法で最短距離を求めることもできます。
うまく書けてるかはわかりませんがこんな感じ。
<pre class="brush:cpp">
struct road{int to,cost;};

int main(){
  while(1){
    vector<road> roads[10];
    int d[10];
    int n,m;

    cin >> n;
    if(!n)break;
    m = 0;
    for(int i=0;i<n;i++){
      int x,y,z;
      scanf("%d%d%d",&x,&y,&z);
      if(m<x||m<y){
        m = max(x,y);
      }
      roads[x].push_back((road){y,z});
      roads[y].push_back((road){x,z});
    }
    m++;

    int minIndex;
    int mini = INF;
    for(int i=0;i<m;i++){
      priority_queue<P, vector<P>, greater<P> > que;
      que.push(P(0,i));
      fill(d,d+m,INF);
      d[i] = 0;
      while(que.size()){
        P p = que.top(); que.pop();
        int dist = p.first;
        int pos = p.second;
        if(d[pos]<dist) continue;
        for(int j=0;j<roads[pos].size();j++){
          int to = roads[pos][j].to;
          int cost = roads[pos][j].cost;
          if(d[to]>d[pos]+cost){
            d[to] = d[pos] + cost;
            que.push(P(d[to],to));
          }
        }
      }
      int sum = 0;
      for(int j=0;j<m;j++){
        //printf("%3d%c",d[j],j==m-1?'\n':' ');
        sum += d[j];
      }
      if(mini>sum){
        mini = sum;
        minIndex = i;
      }
    }
    cout << minIndex << " " << mini << endl;
  }
}

</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AOJ 2249 Road Construction
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: icpc_practice
CATEGORY: icpc_practice

DATE: 07/03/2014 01:13:49
-----
BODY:
ある町に最短で行く経路は複数あり、
そのうち最低のコストのものだけ残せば良い。
そこで最短経路で進んだ場合の
ある町とその一つ前の町をつなぐ道をpreに保存し
preのコストが最小になるように更新していく。
<pre class="brush:cpp">
struct road{int to,dist,cost;};

int main(){
  while(1){
    int n,m;
    vector<road> roads[MAX_N];
    int dist[MAX_N];
    road pre[MAX_N];

    scanf("%d%d",&n,&m);
    if(!n&&!m)break;

    for(int i=0;i<m;i++){
      int u,v,d,c;
      scanf("%d%d%d%d",&u,&v,&d,&c);
      roads[u-1].push_back((road){v-1,d,c});
      roads[v-1].push_back((road){u-1,d,c});
    }

    fill(dist,dist+n,INF);
    priority_queue<P, vector<P>, greater<P> > que;
    dist[0] = 0;
    que.push(P(0,0));
    while(que.size()){
      P p = que.top(); que.pop();
      int d = p.first;
      int pos = p.second;
      //cout << pos+1 << endl;
      if(d>dist[pos]) continue;
      for(int i=0;i<roads[pos].size();i++){
        int to = roads[pos][i].to;
        int co = roads[pos][i].dist + dist[pos];
        //cout << pos+1 <<"->" << to+1<< endl;
        if(dist[to]>co){
          pre[to] = roads[pos][i];
          dist[to] = co;
          que.push(P(dist[to],to));
        }else if(dist[to]==co){
          if(pre[to].cost>roads[pos][i].cost){
            pre[to] = roads[pos][i];
          }
        }
      }
    }

    int sum=0;
    for(int i=1;i<n;i++){
      sum += pre[n-i].cost;
    }
    cout << sum << endl;
  }
}

</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AOJ 2200 Mr. Rito Post Office
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: icpc_practice
CATEGORY: icpc_practice

DATE: 07/03/2014 16:17:45
-----
BODY:
わからなくてぐぐりました。
<a href="http://d.hatena.ne.jp/sune2/20120719/1342723320" target="_blank" title="蟻本の練習問題埋め2-5(1)">http://d.hatena.ne.jp/sune2/20120719/1342723320</a>
<blockquote><p>z[i]からz[i+1]に移動するとき、

    陸路のみ
    陸路　→　海路　→　陸路

のうち、どちらかのタイプの経路を辿る。</p></blockquote>この考え方で実装するとうまくいきます。
dp[i][j]に対して、i-1のとき船があった場所をkとし
z[i-1] →(陸路)→ k →(海路)→ j →(陸路)→ z[i]
と進む事で船を場所jに移し自分はz[i]に移動することができます。
k==jのとき、すなわち船を移動させる必要がないときは、
必ずしもkを経由する必要がないのでz[i-1]からz[i]の陸最短路で良い。
これがわからなくて何回かWAくらった。
<pre class="brush:cpp">
#define N 200
#define M 10000
#define R 1000
#define INF 1000000

int main(){
  while(1){
    int n,m,r;
    int sea[N][N];
    int land[N][N];
    int dp[R][N];
    int z[R];

    scanf("%d%d",&n,&m);
    if(!n&&!m)break;

    //陸路と海路を別々に全点対最短路を求める
    for(int i=0;i<n;i++){
      for(int j=0;j<n;j++){
        if(i==j){
          sea[i][j] = 0;
          land[i][j] = 0;
        }else{
          sea[i][j] = INF;
          land[i][j] = INF;
        }
      }
    }
    for(int i=0;i<m;i++){
      int x,y,t;
      char s;
      scanf("%d %d %d %c",&x,&y,&t,&s);
      if(s=='S'){
        sea[x-1][y-1] = t;
        sea[y-1][x-1] = t;
      }else{
        land[x-1][y-1] = t;
        land[y-1][x-1] = t;
      }
    }
    for(int k=0;k<n;k++){
      for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);
          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);
        }
      }
    }

    scanf("%d",&r);
    for(int i=0;i<r;i++){
      scanf("%d",&z[i]);
      z[i]--;
    }

    //dp[i][j]をjに船をおいてz[i]まで進んだ時にかかる最短の時間
    for(int i=0;i<n;i++){
      dp[0][i] = sea[z[0]][i] + land[i][z[0]];
      for(int j=1;j<r;j++){
        dp[j][i] = INF;
      }
    }
    for(int i=1;i<r;i++){
      for(int j=0;j<n;j++){
        for(int k=0;k<n;k++){
          dp[i][j] = min(
            dp[i][j],
            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );
          if(k==j) dp[i][j] = min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);
        }
      }
    }

    int ans = INF;
    for(int i=0;i<n;i++){
      ans = min(ans,dp[r-1][i]);
    }
    cout << ans << endl;
  }
  return 0;
}


</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: AOJ 2224 Save your cat
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: icpc_practice
CATEGORY: icpc_practice

DATE: 07/03/2014 20:16:51
-----
BODY:
フェンスを辺と考え、閉路をなくせばよいので、
閉路をなくす　→　全域木の辺の数を最小にする
壊す長さを最小に　→　長い辺から使っていく
と考えると最小全域木と同じような解き方で解けます。

UnionFind木を使ったクラスカル法で解く場合。
fenceをcostの大きさで降順にソートして、
使わなかったfenceのcostの和を出力します。
<pre class="brush:cpp">
struct fence{
  int u,v;
  double cost;
};

//union-find木
#define N 10000
int par[N];
int urank[N];
void init(int n){
  for(int i=0;i<n;i++){
    par[i] = i;
    urank[i] = 0;
  }
}
int find(int x){
  if(par[x] == x){
    return x;
  }else{
    return par[x] = find(par[x]);
  }
}
void unite(int x,int y){
  x = find(x);
  y = find(y);
  if(x==y)return;

  if(urank[x]<urank[y]){
    par[x] = y;
  }else{
    par[y] = x;
    if(urank[x]==urank[y])urank[x]++;
  }
}
bool same(int x,int y){
  return find(x)==find(y);
}

//2点間の距離を求める
double distance(int x1,int y1,int x2,int y2){
  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

//fenceはcostの大きさで降順ソートしたいので不等号はこの向き
bool cmp(const fence &a,const fence &b){
  return a.cost > b.cost;
}

int main(){
  int n,m;
  P piles[N];
  vector<fence> fences;

  scanf("%d%d",&n,&m);
  for(int i=0;i<n;i++){
    int x,y;
    scanf("%d%d",&x,&y);
    piles[i] = P(x,y);
  }
  for(int i=0;i<m;i++){
    int p,q;
    scanf("%d%d",&p,&q);
    p--;q--;
    double c = distance(piles[p].first,piles[p].second,piles[q].first,piles[q].second);
    fences.push_back((fence){p,q,c});
  }

  double sum = 0;
  init(n);
  sort(fences.begin(),fences.end(),cmp);
  for(int i=0;i<m;i++){
    int u = fences[i].u;
    int v = fences[i].v;
    if(same(u,v)){
      sum += fences[i].cost;
    }else{
      unite(u,v);
    }
  }

  printf("%.3f\n",sum);


  return 0;
}


</pre>
プリム法で解く場合。
プリム法は最小全域"木"をつくるので、森をつくるため、
使われていない頂点に対して何度かプリム法で木を作ります。
(森に対してプリム法を使う方法これしかおもいつかない……)
あと、この実装方法だと同じ辺を何度もみることがあるので
クラスカル法の時のように素直にsumを出力できません。
<pre class="brush:cpp">
typedef pair<int,int> P;
typedef pair<double,int> Pdi;
#define N 10000
struct fence{
  int to;
  double cost;
};

//2点間の距離を求める
double distance(int x1,int y1,int x2,int y2){
  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

int main(){
  int n,m;
  P piles[N];
  vector<fence> fences[N];
  double costsum = 0;

  scanf("%d%d",&n,&m);
  for(int i=0;i<n;i++){
    int x,y;
    scanf("%d%d",&x,&y);
    piles[i] = P(x,y);
  }
  for(int i=0;i<m;i++){
    int p,q;
    scanf("%d%d",&p,&q);
    p--;q--;
    double c = distance(piles[p].first,piles[p].second,piles[q].first,piles[q].second);
    fences[p].push_back((fence){q,c});
    fences[q].push_back((fence){p,c});
    costsum += c;
  }

  double sum = 0;
  bool used[N];
  fill(used,used+n,false);

  priority_queue<Pdi> que;
  for(int i=0;i<n;i++){
    if(!used[i]){
      que.push(Pdi(0,i));
      while(que.size()){
        Pdi p = que.top(); que.pop();
        int pos = p.second;
        if(used[pos]) continue;
        used[pos] = true;
        sum += p.first;
        for(int j=0;j<fences[pos].size();j++){
          que.push(Pdi(fences[pos][j].cost,fences[pos][j].to));
        }
      }
    }
  }

  printf("%.3f\n",costsum-sum);


  return 0;
}


</pre>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: GitHubアカウント作りました
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: お知らせなど
CATEGORY: お知らせなど

DATE: 07/17/2014 12:58:46
-----
BODY:
つくりました。
この間参加したイベントでGitHubで公開できるWebページで
WebRTCを試せるという話を聞いたのでつくってみました。
<a href="https://github.com/zaburo-ch" target="_blank" title="github">https://github.com/zaburo-ch</a>

使い方の練習もかねて、ICPCの練習で書いたコードを
<a href="https://github.com/zaburo-ch/icpc_practice" target="_blank" title="icpc_practice">https://github.com/zaburo-ch/icpc_practice</a>
にアップロード(?)しました。
コードをガシガシ載せていくと言いましたが、
書いたコードを全部を記事にすることはできないので
ここにあげたものからピックアップして記事を書く
という形にしていきたいと思います。

あれ？これgistっての使った方がいいの？
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【JQuery mobile】ポップアップからポップアップを開く方法
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 09/26/2014 13:42:20
-----
BODY:
JQuery mobileのポップアップのボタンなどを押して
更にポップアップを開こうとするとうまく開いてくれません。

おそらく2重にポップアップが開かれないようになっているのだと思います。
仕方が無いので今開いているポップアップを閉じてから
新しくポップアップを開くようにしてみたのですが、
古いポップアップが閉じるのみで新しいポップアップが開きません。
ポップアップが閉じてから新しいポップアップが開けるまで
タイムラグのようなものがあるのかもしれません。

以下のようにして動かしました。
<pre>function openPopup(){
  closePopup();
  var timerId;
  $("#popup").bind({
    popupafteropen:function(event, ui){
      clearInterval(timerId);
    }
  });
  timerId = setInterval(function(){
    $("#popup").popup('open');
  },100);
};

function closePopup(){
  //開いているポップアップを閉じる処理
}
</pre>
ちゃんと開いてくれるまでopenを繰り返して
openされたら繰り返しを止める感じですね！安直！
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: Wikipediaでリンクを辿って遊ぶ
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 10/03/2014 18:01:51
-----
BODY:
Wikipediaでリンクを辿って遊ぶのがなかなか楽しいです。

Wikipediaのあるページから全く関係のないページに、
記事内のリンクだけを使ってどれだけ早くつけるか競うゲームです。
例えば「リオネル・メッシ」から「貞子3D2」とか。

リンクを辿るごとに目的の記事に近づいたり離れたりが
なんとなくですがわかるので結構楽しいです。
メッシなら「アルゼンチン入った！」とか「サッカーまで来た」とか。
色々なルートがあるのも楽しいです。

ゴールしたらそこからスタートすると辿ってる感がでるし、
負けた方が次のゴール決めたり、
「戻る」禁止にしたりルール次第でかなり面白くなると思います。


こんな感じで遊んでいるうちに
Wikipediaのページ間の距離(?)に興味がわいてきたので、
<a href="http://dumps.wikimedia.org/other/pagecounts-raw/" target="_blank" title="Page view statistics for Wikimedia projects"><strong>Page view statistics for Wikimedia projects</strong>
http://dumps.wikimedia.org/other/pagecounts-raw/</a>
からデータを頂いてきてpythonでいろいろやってみたので
近いうちに記事にしようと思います。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: とんぺーのミスコンにエントリーした気分になれるブックマークレットつくった
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: つくった
CATEGORY: つくった

DATE: 10/07/2014 22:40:04
-----
BODY:
使い方

1.幅140px高さ260pxの画像を用意する。

2.画像のURLをこのテキストボックスに入れる。<script src="http://blog-imgs-60.fc2.com/z/a/b/zaburoapp/fc2_fes4.js"></script>
<input type="text" size="80px" value="ここに画像のURLを入れて下さい" id="imgurl" onblur="onb();"></input>

3.このリンクを右クリックしてブックマーク
<a href="#" id="bookmarklink"><strong>学祭ミスコン ブックマークレット</strong></a>

4.コンテストの公式ページに行く
<a href="http://www.festa-tohoku.org/program/contest/contest.html" target="_blank" title="第6回Mr.&amp;Ms.東北大コンテスト"><strong>第6回Mr.&Ms.東北大コンテスト
http://www.festa-tohoku.org/program/contest/contest.html</strong></a>

5.先ほどのブックマークを開く！
5人目のミス候補が現れます。

マウスを画像にのせたときの白いオーバーレイは実装しましたが、
名前やNo.5の記述は省略しました。
以下に元のコードを載せるので、誰かやって！

<pre>
var imgurl = 'ms1.jpg';
var msul = $('ul').eq(1);
msul.children().attr('style','margin-right:25px;');
var newms = $('<li>');
newms.css({
	'position':'relative',
	'float':'left',
	'width':'150px',
	'height':'270px',
	'background-image':'-moz-linear-gradient(top,#931f20,#f29d80 50%,#931f20)'
});
newms.css('background-image','-webkit-gradient(linear,left top,left bottom,from(#931f20),color-stop(0.5, #f29d80),to(#931f20))');
var msimg = $('<img>');
msimg.attr('src',imgurl);
msimg.css({
	'position':'absolute',
	'top':'5px',
	'left':'5px',
});
newms.append(msimg);
var overlay = $('<div>');
overlay.css({
	'position':'absolute',
	'top':'4px',
	'left':'4px',
	'width':'142px',
	'z-index':'100',
	'height':'262px',
	'background':'rgba(255,255,255,0.15)'
});
overlay.hide();
newms.append(overlay);
newms.hover(
	function(){
		overlay.show();
	},
	function(){
		overlay.hide();
	}
);
msul.append(newms);
</pre>
コードが書けたら以下のページで適当な形に変換すれば、
ブックマークレット化できます。
<a href="http://userjs.up.seesaa.net/js/bookmarklet.html" target="_blank" title="bookmarklet maker"><strong>bookmarklet maker
http://userjs.up.seesaa.net/js/bookmarklet.html</strong></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: Wikipediaのアクセス上位10000ページの距離を計算した話
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: つくった
CATEGORY: つくった

DATE: 10/17/2014 23:44:17
-----
BODY:
先日の記事の続きです。

<a href="http://zaburoapp.blog.fc2.com/blog-entry-24.html" target="_blank" title="Wikipediaでリンクを辿って遊ぶ">Wikipediaでリンクを辿って遊ぶ
http://zaburoapp.blog.fc2.com/blog-entry-24.html</a>

今回探したのはWikipediaに存在する記事のうち
最も距離のはなれている記事の組み合わせです。

ここで言う距離とは、ある記事から記事内のリンクのみを辿って行く時
何回リンクを踏めばその記事に辿り着くかを表した数字です。
複数あるルートのうち最も短いものをその組の距離としました。

さて、Wikipediaについてですが、
<a href="http://ja.wikipedia.org/wiki/Wikipedia:%E5%85%A8%E8%A8%80%E8%AA%9E%E7%89%88%E3%81%AE%E7%B5%B1%E8%A8%88" target="_blank" title="Wikipedia:全言語版の統計">Wikipedia:全言語版の統計
http://ja.wikipedia.org/wiki/Wikipedia:%E5%85%A8%E8%A8%80%E8%AA%9E%E7%89%88%E3%81%AE%E7%B5%B1%E8%A8%88</a>
によれば、2014年10月17日現在
純記事数は全言語総計でなんと<strong>33,448,472</strong>もあるそうです。
日本語のものだけで<strong>930,619</strong>もあるので
これをすべて解析するとなると人生が終わるまでに
計算し終わるかという問題が出てきます。

というわけで今回は、日本語版Wikipediaの記事のうち
ある日の閲覧数が上位の記事を一定数とって来て
その記事のみを対象にページ間距離を計算しました。

技術的なことは後日記事にするとして
早速結果を書いていきたいと思います。

まず2014年9月1日の閲覧数上位1000位に限定した場合の結果。
上位20位のみを抜粋しました。
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;--

List of longest distance between Wikipedia pages
20140901 : Page view Top 1000

   1:  8 続柄 -> 近江友里恵
   2:  8 続柄 -> たちかぜ自衛官いじめ自殺事件
   3:  8 国鉄105系電車 -> たちかぜ自衛官いじめ自殺事件
   4:  8 七草 -> 近江友里恵
   5:  8 七草 -> たちかぜ自衛官いじめ自殺事件
   6:  8 カルトの集団自殺 -> 近江友里恵
   7:  8 カルトの集団自殺 -> たちかぜ自衛官いじめ自殺事件
   8:  8 特別:最近の更新 -> 近江友里恵
   9:  8 特別:最近の更新 -> たちかぜ自衛官いじめ自殺事件
  10:  8 カツオノカンムリ -> 近江友里恵
  11:  8 カツオノカンムリ -> たちかぜ自衛官いじめ自殺事件
  12:  8 城井鎮房 -> たちかぜ自衛官いじめ自殺事件
  13:  8 奇皇后 -> 近江友里恵
  14:  8 奇皇后 -> たちかぜ自衛官いじめ自殺事件
  15:  8 標準偏差 -> 近江友里恵
  16:  8 標準偏差 -> たちかぜ自衛官いじめ自殺事件
  17:  8 青春18きっぷ -> たちかぜ自衛官いじめ自殺事件
  18:  8 特別:検索 -> 近江友里恵
  19:  8 特別:検索 -> たちかぜ自衛官いじめ自殺事件
  20:  8 龍虎 -> たちかぜ自衛官いじめ自殺事件

&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;--

たちかぜ自衛官いじめ自殺事件の存在感が半端ないですね。
8回リンク踏むだけでいけちゃうということで
案外短くてがっかりしました。
105位まで距離8がありその後2500位くらいまで距離7が続きます。

思った以上に大したことが無い結果が出てしまったので
上位10000ページでもやりたいところですが、
上位1000ページでさえ20分程度時間がかかっていて、
最短距離の計算につかったアルゴリズムの計算量がO(n^3)なので
約1000倍の時間がかかることになります。

終わるまでの時間を計算してみた結果、
まあ現実的な時間で終わるだろうという数字が出たので
ここ数日ずっとパソコンをフル稼働させて計算していました。

そして、その結果が今日、出ました！
利用したデータは2014年10月1日の閲覧数上位10000ページ。
要した時間なんと<span style="font-size:large;"><strong>261時間！</strong></span>
その結果は！

<span style="font-size:x-large;"><strong>保存できませんでした！</strong></span>

というのも使ったパソコンには4GBしかメモリが積まれていないので
ターミナルの出力をコピーしようとした瞬間
ターミナルがフリーズして永遠の眠りについてしまいました。
何とかログの復旧を試みたのですが
89129689位以降というまったく意味のないデータしか復元できませんでした。

<strong><span style="font-size:large;">最も離れている距離は6</span></strong>だったのは確認しました。
1000ページの時より小さい結果となりましたが、
ページが増える事で新しいより短いルートが生まれたのだと思います。

結果が公開できないのは大変残念ですが、
そもそもいけないページを除けば、
6回リンクを踏むだけで大体のページ同士はいけてしまうというのは
10000ページに限られてるとはいえなかなか面白い結果だと思います。
普段みるようなページは大体10000ページの中に含まれていますしね。

250時間以上ずっと電源をつけて、ファンがまわるほど計算させていたので
使ったMacbook Airのバッテリーが心配になりました。
二度とやりません！

詳しい方法等はソースコードとともに後日記事にしたいと思います。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: Wikipediaのページ解析に使ったpythonコード
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: つくった
CATEGORY: つくった

DATE: 11/30/2014 01:36:54
-----
BODY:
すっかりわすれていましたがソースコードです。
とりあえずpython触ってみようくらいの気持ちで書いたコードなので
pythonに慣習みたいなものがあるならたぶんそれには従えていません。
multiprocessing、numpy、pandasあたりをちゃんと使えば
格段に早くすることもできるかもしれません。やんないけど。

python wikipedia.py 20141101
のようにして日付指定して使います。

以下のようなことをやってます。
・http://dumps.wikimedia.orgから1時間ごとの閲覧数のデータを1日分取ってくる
・国コード(?)がjaの物だけ抽出する
・標準ライブラリのCounterで各ページの1日分の閲覧数をカウントする
・閲覧数上位10000ページを取り出す
・1ページずつ開き記事内の/wiki/で始まるリンクを抽出する
・リンクがあれば距離1なければINFとして(ディクショナリで)隣接行列をつくる
・ワーシャルフロイド法で全点間最短距離を求める
・ソートして表示

<script src="https://gist.github.com/zaburo-ch/d2fceee659bd28ef7e22.js"></script>
Gistを使ってみました。綺麗に表示してくれますね。
過去の物をGistに置き換えたりはしませんが
今後はできるだけこれをつかっていこうと思います。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【matplotlib】図の余白を設定する
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 12/17/2014 17:35:15
-----
BODY:
subplots_adjustが何者か調べたのでメモ。
matplotlib(1.4.2)で動作確認しました。

subplots_adjustは図の位置を設定するメソッドです。
これを使う事で余白を変更指定する事が出来ます。たぶん。
<a href="http://matplotlib.org/api/figure_api.html#matplotlib.figure.Figure.subplots_adjust" target="_blank">http://matplotlib.org/api/figure_api.html#matplotlib.figure.Figure.subplots_adjust</a>

図の大きさを1として、
topとbottomは下から、leftとrightは左からの長さを指定します。
wspaceとhspaceは複数のグラフがまとまっているときの余白とかそんな感じ。

デフォルトの値は下記の通り
left : 0.125
right : 0.9
bottom : 0.1
top : 0.9
wspace : 0.2
hspace : 0.2

以下のサンプルでは、デフォルトのままのグラフと
各値を0.05(5%分)減らしたグラフを表示するようにしました。

<script src="https://gist.github.com/zaburo-ch/733528b92d5e95be4b86.js"></script>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: JQuery mobileでPhonegap(Cordova)アプリをつくる
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 12/18/2014 21:51:43
-----
BODY:
cordova4.1.2で動作確認しております。

基本的には普通にJQuery mobile使って書くだけなんですが、
そのままだと、iOS7.0以降の上部のステータスバー的なものと
JQuery mobileのヘッダが重なってしまいます。

そのため、iOS7.0以降でのみヘッダの上にマージンをが設定されるようにします。
.css()とかでやってもpage遷移後に機能しなかったので、
style要素を動的に追加する方法にしたらうまくいきました。

まずwindow.deviceを使うためにpluginを追加します。
$ cordova plugin add org.apache.cordova.device

ソースは以下の通り。
<script src="https://gist.github.com/zaburo-ch/0beb1ac8d6d02de69726.js"></script>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【python】文字列のバイト数を取得する
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 02/28/2015 16:18:09
-----
BODY:
str型の文字列sならlen(s)とするだけでバイト数が取得できます。
てっきり文字数が返ってくるものだと思っていたのでメモ。

ちなみに文字数の取得は len(s.decode('utf-8'))
マルチバイト文字が入ってない場合はバイト数＝文字数なのでそのままlen(s)でも可能。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: Xcode6でサンプルコードSonofGrabのビルドができない
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 03/07/2015 21:50:12
-----
BODY:
実行中のウィンドウのリストを取得する方法が知りたくて
SonofGrab というサンプルに行き着いたのですが
エラーでちゃいました。

環境は OSX10.9.4 Xcode6.1.1 です。

まず、古いSDKが指定されたままでビルドができないので
Build SettingsからBase SDKを自分のOSにあったものにします。
するとビルドが行われますがそこでもエラーがおきます。
適当にぐぐると以下のページが見つかります。

<a href="http://stackoverflow.com/questions/12844729/linking-error-for-inline-functions" target="_blank" title="objective c - Linking error for inline functions - Stack Overflow"><u>objective c - Linking error for inline functions - Stack Overflow
http://stackoverflow.com/questions/12844729/linking-error-for-inline-functions</u></a>

具体的には
Controller.mの71行目のinlineの前にstaticをつけるだけです。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【PokerStars】無料で使えるHUDつくった【ver0.1】
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: PokerStars
CATEGORY: PokerStars

DATE: 03/26/2015 20:37:03
-----
BODY:
つくりました。

自分の環境で2週間程度使ってみて
そこそこまともに動くし、そこそこ使えると感じたので
アプリとして公開してみようと思います。

実装したのがまだまだ限定的な機能だけなので
ベータ版という感じです。名前も開発中のもの。
実装してほしい機能、指標などがあれば
記事へのコメント等で教えて頂ければと思います。
いつ実装されるか定かではありませんけどね！

Windowsが入ってるPCを持っていないため、
今回はMac用しか公開することができませんでしたが、
中身はPythonなので希望があればexeファイルつくります。
希望がなくてもいずれつくります。

以下アプリの説明になります。
ダウンロードは記事の一番下です。

&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;

【使用する前に】
PokerStarsのハンド履歴から情報を読み取っているため、
使用するにあたって設定を変更しなければならない場合があります。
以下の項目をご確認ください。
・言語設定が日本語になっているか
・ハンド履歴を保存する設定になっているか
・テーブルテーマがMercuryになっているか
・画面中央の席に座る設定になっているか

【使い方】
1. 「履歴ファイルを選択」から読み込みたいファイルを選ぶ
まだそのトーナメントで1度もハンドをプレイしていないと、
履歴ファイルが作成されないため1ハンド以上プレイしてから行って下さい。

2. プレイ画面にあわせる。
ハンド履歴を選択するとテーブルの人数分の黒いタイルと
2つの小さくて白いタイルが表示されます。
画面を移動させたいときは黒いタイルを、
画面を拡大縮小させたいときは白いタイルをドラッグして
プレイ画面の左上と右下に白いタイルがくるように動かして下さい。

黒いタイルに各プレイヤーの情報が表示されます。

【プレイヤーの情報の見方】
黒いタイルに表示される情報は次のとおりです。

名前(プレイしたハンド数)
VPIP/PFR/PFA/WTSD

【指標の定義】
ここで、参加はテーブルにつきカードをもらうことを言います。
VPIP : 1度でもポッドにお金を入れたハンド / 参加したハンド
PFR  : プリフロップで(自分がまだお金を出していない状態から)レイズしたハンド / 参加したハンド
PFA  : ポストフロップでレイズorベットした回数 / コールした回数
WTSD : ショウダウンまで行った回数 / ポストフロップまで行った回数

【多面したい場合】
ターミナルで
open -n ≪アプリの場所≫
とすると同じアプリを複数開けるのでこれをご利用ください
アプリをApplicationsにコピーした場合は
open -n "/Applications/MyPoker Beta-0.1.app"
となります。
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;

アプリの説明は以上です。
追加したいと思っている機能がいくつかあるので
それをメモしておきます。
・他の指標に対応する
・黒いタイルに表示する指標をユーザーが設定できるようにする
・多面にアプリ側で対応する
・自動で画面にあわせられるようにする
・PokerStars以外のアプリと重なったとき上にこないようにする

こんな指標が欲しい！などコメント頂ければ
できるだけ対応するつもりです。
またこんな環境で動いた、動かないなど
動作確認のコメント頂けると大変有り難いです。


<strong>こちらからダウンロードしてご利用ください↓</strong><a href="https://github.com/zaburo-ch/poker_tool/raw/master/MyPoker-Beta-0.1.dmg" target="_blank" title="MyPoker-Beta-0.1.dmgをダウンロード">
<u>MyPoker-Beta-0.1.dmgをダウンロード</u></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: Mac OS Xで時々ジェスチャーが反応しなくなる
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: つくった
CATEGORY: つくった

DATE: 03/24/2015 17:21:45
-----
BODY:
普段ウインドウの切り替えはMission Controlでやっているのですが、
ときどきジェスチャーが反応しなくなってしまって、
仮想デスクトップの切り替えもできなくなるものですから
再起動しなければならなくなる、というのが近頃起こります。

原因はよくわからないのですが、
OSまるごと再起動しなくてもDockを再起動させてやるだけで
なんとかなるみたいです。

ps -x | grep Dockで出てきたPIDを指定してkillしてやると
自動で起動してくれるようなのでこれで済ませていますが
面倒なので実行ファイルへの変換の勉強がてら
ちょっと書いてアプリにしてみました。

<a href="http://zaburoapp.blog.fc2.com/img/a.png/" target="_blank"><img src="http://blog-imgs-74.fc2.com/z/a/b/zaburoapp/a.png" alt="a.png" border="0" width="139" height="102" /></a>
こんな感じでDockに配置して使っています。

アイコン画像は以下のものを利用させて頂きました。
<a href="http://www.easyicon.net/language.ja/1088483-stop_icon.html" target="_blank" title="http://www.easyicon.net/language.ja/1088483-stop_icon.html"><u>http://www.easyicon.net/language.ja/1088483-stop_icon.html</u></a>

ソース等はこちら
<a href="https://github.com/zaburo-ch/DockKiller" target="_blank" title="https://github.com/zaburo-ch/DockKiller"><u>https://github.com/zaburo-ch/DockKiller</u></a>

こちらからダウンロードしてご利用ください↓
<a href="https://github.com/zaburo-ch/DockKiller/raw/master/DockKiller-1.0.dmg" target="_blank" title="DockKiller-1.0.dmgをダウンロード"><u>DockKiller-1.0.dmgをダウンロード</u></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【PokerStars】無料で使えるHUD更新した【ver0.2】
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: PokerStars
CATEGORY: PokerStars

DATE: 03/27/2015 00:51:38
-----
BODY:
同じデスクトップ内での多面打ちに対応しました。

終了ボタンがあるウィンドウとHUD部分とを
別々のデスクトップおく事が出来ないため
同じデスクトップ内のみですが、複数のHUDを出せるようにしました。
プレイ画面を並べて多面する際に使って下さい！

また、更新する度に使い方を載せるのは見づらくなるだけだと思ったので
GitHub上に使い方などを書いたREADME.mdと
アプリ本体をおく場所をつくりました。
こちらからアクセスしてダウンロードしてください！<a href="https://github.com/zaburo-ch/poker_tool" target="_blank" title="zaburo-ch/poker_tool"><u>
zaburo-ch/poker_tool</u></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【PokerStars】無料で使えるHUD更新した【ver0.3】
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: PokerStars
CATEGORY: PokerStars

DATE: 03/27/2015 15:19:16
-----
BODY:
右下の白いタイルが動かないバグがあったため修正しました。

こちらからアクセスしてダウンロードしてください！<a href="https://github.com/zaburo-ch/poker_tool" target="_blank" title="zaburo-ch/poker_tool"><u>
zaburo-ch/poker_tool</u></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 動的時間伸縮法(DTW)をPythonで試してみた
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 04/06/2015 18:36:47
-----
BODY:
ここ数ヶ月くらい、ある時系列データを集めていたのですが、
そのデータを扱うにあたってまずデータを分類したいと思い
クラスタリングについて調べたところ
どうやらクラスタリングにはまず距離を定義しなければいけないらしい。

時系列データの距離？は？と思っていたら
このようなページがありました。

<a href="http://sinhrks.hatenablog.com/entry/2014/11/14/232603" target="_blank" title="動的時間伸縮法 / DTW (Dynamic Time Warping) を可視化する"><u>動的時間伸縮法 / DTW (Dynamic Time Warping) を可視化する
http://sinhrks.hatenablog.com/entry/2014/11/14/232603</u></a>

Rの{TSculst}というパッケージを使えば簡単に計算できるそうですが、
有り難い事にDTW距離算出の実装を載せてくれているので
Python用に書き直してみました。

<script src="https://gist.github.com/zaburo-ch/6c16ecb3a4e25ee0d076.js"></script>
英語力低すぎて<a href="http://en.wikipedia.org/wiki/Dynamic_time_warping" target="_blank" title="英語版Wikipedia"><u>英語版Wikipedia</u></a>があまり理解できなかったのですが、
dは点同士の距離を定義する関数(初期値は差の絶対値)となる引数で、
windowは、ある点から距離を計算する対象となる点を
windowで指定した範囲に制限する場合の引数であってると思います。

参考にさせて頂いたページにならって
RのデータセットAirPassengersでテストするようにしていますが、
PythonでRのデータセット利用する方法については
以下のページを参照してください。めっちゃ便利です。
<a href="http://kumamotosan.hatenablog.com/entry/2014/03/02/231742" target="_blank" title="PythonでRの標準データセットを使う。http://kumamotosan.hatenablog.com/entry/2014/03/02/231742"><u>PythonでRの標準データセットを使う。
http://kumamotosan.hatenablog.com/entry/2014/03/02/231742</u></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【Python】PageRankアルゴリズム
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: つくった
CATEGORY: つくった

DATE: 05/14/2015 20:54:05
-----
BODY:
PageRankというアルゴリズム、
以前からなんとなくは知ってはいたのですが、
ランダムサーファーモデルで計算する方法を聞いて、
めちゃくちゃ賢いなこれーって思ったので実際にやってみました。

ひとまずPageRankについて調べたことを纏めます。

PageRankは基本的に次の２つの考え方でページの重要度を推定します。
・多くのページからリンクされているページの質は高い
・質の高いページからリンクされているページの質は高い

これを数学的に考えるのにランダムサーファーモデルを利用します。
ランダムサーファーモデルでは
ページのリンク関係を有向グラフとして考え、
人(サーファー)にこの有向グラフをランダムに辿らせたとき、
人が居る確率が高いページを重要とします。

まず、ページの総数をNとし、N次正方行列<strong>M</strong>を
<strong>M</strong>[i][j] = ページjにいるサーファーがページiに移動する確率
と定義します。
例えばページ0にページ1とページ5へのリンクしかないとすると、
サーファーはランダムに移動するので
<strong>M</strong>[i][0]は i=1or5 のとき1/2 となりそれ以外のiでは0となります。

また、ベクトル<strong>P</strong>(t)を時刻tに各ページに人がいる確率とすると
<strong>P</strong>(0)は全ての要素が 1/N のベクトルとなり
<strong>P</strong>(t+1)は<strong>M</strong>と<strong>P</strong>(t)の積を取ることで計算できます。

有向グラフが強連結のとき、この遷移を無限に繰り返すことで
<strong>P</strong>はtに依らない一定の値に収束します。よってこの<strong>P</strong>は
<strong>M P</strong> = <strong>P</strong>
の解を要素の和が1になるよう正規化してあげることにより求められます。

この<strong>P</strong>の大きさが各ページの重要度となります。

----
行列計算において <strong>Ax</strong> = λ<strong>x</strong> を解く、というのは固有値問題と言って
色々な方法が考えられているらしいのですが、ここについては
<a href="http://www.cms-initiative.jp/ja/events/0627yamamoto.pdf" target="_blank" title="行列計算における高速アルゴリズム"><u>行列計算における高速アルゴリズム
http://www.cms-initiative.jp/ja/events/0627yamamoto.pdf</u>
</a>こちらのページが詳しいです。
Pythonではscipy.sparse.linalg.eigsを使うと
Implicitly Restarted Arnoldi で計算してくれます。
ただ、<strong>M P</strong> = <strong>P</strong> を解くだけのためにこれらを使うのが速いのかは
勉強不足で僕もよくわかっていません。
----

実際のウェブページでは、ページ間の関係を有効グラフにしても
必ずしも上で述べたような強連結になるわけではありません。
そのため「一定の確率でサーファーはリンクを辿らずにランダムに移動する」
という考えを新たに導入します。その時はMにあたるものを
全ての要素が 1/N である N次正方行列Uと普通にリンクを辿る確率αを用いて
(α<strong>M</strong> + (1-α)<strong>U</strong>) として計算することによって<strong>P</strong>が求められます。


次の図のようなリンク関係にあるページのPageRankを
Pythonを利用して実際に計算してみます。
正しく計算できれば図の通りの値が得られるはずです。

<img src="http://blog-imgs-74.fc2.com/z/a/b/zaburoapp/Linkstruct2.gif" alt="Linkstruct2.gif" border="0" width="400" height="368" />
<span style="font-size:x-small;">
The original uploader was <a title="wikipedia:User:Gnix" href="//en.wikipedia.org/wiki/User:Gnix">Gnix</a> at <a title="wikipedia:" href="//en.wikipedia.org/wiki/">English Wikipedia</a>[<a href="http://www.gnu.org/copyleft/fdl.html" target="_blank" title="GFDL">GFDL</a> or <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" title="CC-BY-SA-3.0">CC-BY-SA-3.0</a>]</span>

コードはこちら
<a href="https://github.com/zaburo-ch/wikipedia_analysis/blob/master/pagerank.py" target="_blank" title="zaburo-ch/wikipedia_analysis/master/pagerank.py"><u>zaburo-ch/wikipedia_analysis/master/pagerank.py</u></a>

get_pagerankではScipyを用いて固有ベクトルを計算しています。
get_pagerank_simpleではもっと単純に
<strong>P</strong>(0)に何度も<strong>M</strong>をかけていき、
かける前との差が十分小さくなるまで繰り返しています。

実行結果はこんな感じです。
<img src="http://blog-imgs-74.fc2.com/z/a/b/zaburoapp/pagerankresult.png" alt="pagerankresult.png" border="0" width="273" height="258" />

図の値とかなり一致していますね！
2つの方法どちらもほぼ同じ値になっているので
get_pagerank_simpleの方法でも十分実用に足りそうです。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: Wikipediaの記事でPageRankを計算してみた。
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: つくった
CATEGORY: つくった

DATE: 05/14/2015 22:36:00
-----
BODY:
PageRankの記事の続きです。

<a href="http://zaburoapp.blog.fc2.com/blog-entry-38.html" target="_blank" title="【Python】PageRankアルゴリズム"><u>【Python】PageRankアルゴリズム
http://zaburoapp.blog.fc2.com/blog-entry-38.html</u></a>

PageRank実装だけして終わるのももったいないので
Wikipediaのページ内でPageRank計算してみました。

コードはこちら
<a href="https://github.com/zaburo-ch/wikipedia_analysis" target="_blank" title="zaburo-ch/wikipedia_analysis"><u>zaburo-ch/wikipedia_analysis
https://github.com/zaburo-ch/wikipedia_analysis</u></a>
前に作ったwikipedia.pyのコードとまとめてレポジトリにしました。

pagerank_wiki.pyを実行すると次のような動作をします。
・<a href="http://dumps.wikimedia.org" target="_blank" title="http://dumps.wikimedia.org"><u>http://dumps.wikimedia.org</u></a>より1日分のデータを取得
・国コードがjaのもののうち閲覧数上位10000ページを取り出す
・各ページの記事内のリンクをエッジとした有向グラフつくる
・有向グラフ内でPageRankを計算し大きい順に出力する

やってることはかなりwikipedia.pyに近いですが、
見返してみるとあまりにもなコードだったのでかなり書き換えました。
他にもリンク抽出にHTMLParser使ってみたりいろいろ変えてます。

前のやつと違って計算の部分にそれほど時間がかからないので
スペック次第ですが少なくとも寝てる間くらいには終わると思います。
リンク解析もこっちのほうがかなり早いです。

さて、肝心の実行結果はこんな感じです。
<a href="http://zaburoapp.blog.fc2.com/img/pagerankwikiresult.png/" target="_blank"><img src="http://blog-imgs-74.fc2.com/z/a/b/zaburoapp/pagerankwikiresult.png" alt="pagerankwikiresult.png" border="0" width="435" height="400" /></a>
<a href="https://github.com/zaburo-ch/wikipedia_analysis/blob/master/pagerank_wiki_data/result.txt" target="_blank" title="wikipedia_analysis/pagerank_wiki_data/result.txt"><u>wikipedia_analysis/pagerank_wiki_data/result.txt</u></a>

「特別:カテゴリ」がぶっちぎりで大きいですね。
確認してみたところほぼ全てのページの一番下に
「特別:カテゴリ」へのリンクがあったのでたぶんそのせいです。
「Wikipedia:出典を明記する」とかもこの類いかな。

「日本」や年がおおいのは人とか何かの作品の記事の
テンプレート化している右の枠内で登場することが多いためだと思います。

テレビ局が上位に多いのはテレビ番組からほぼ確実にリンクされているのと
閲覧数上位10000ページで限定しているため
そのなかでテレビ番組が多かったためではないかと考えています。

上位はほとんどが誰でも知っているような一般的な言葉なんですが、
101位のインターネット・ムービー・データベースってやつ、
全然何のことかわからないです。
「集英社」とか「台湾」より上なので、
かなり多くページがここにリンクしてるはずなんですが、
これどんなページからリンクされてるんでしょう？

全体的にPageRankはWikipediaのページの重要性判断としては
あまり向いていないように思いました。
WikipediaにはPageRankの基本的な考え方が合ってないですしね。
ほかのWebサイトでも試してみればもっと面白い結果が得られるかもしれません。
機会があればやってみたいと思います。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【C++】vectorは==で比較できる
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: 未分類
CATEGORY: 未分類

DATE: 05/18/2015 19:18:45
-----
BODY:
知らなかったのでメモ

<a href="http://www.cppll.jp/cppreference/cppvector_details.html" target="_blank" title="C++ ベクタ"><u>C++ ベクタ
http://www.cppll.jp/cppreference/cppvector_details.html</u></a>

<script src="https://gist.github.com/zaburo-ch/56b43044d09bac1b603d.js"></script>
Javaでのオブジェクトの比較みたいに
アドレスが比較されちゃうんだと勘違いしてた。
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----


--------
AUTHOR: ZABURO
TITLE: 【C++】mainなどの関数の中では大きな配列を確保できない
STATUS: Publish
ALLOW COMMENTS: 1
CONVERT BREAKS: default
ALLOW PINGS: 1
PRIMARY CATEGORY: メモ
CATEGORY: メモ

DATE: 06/17/2015 02:48:23
-----
BODY:
これがSegmentation faultになるのに対して
<script src="https://gist.github.com/zaburo-ch/f7a91485933876727a59.js"></script>
これは正しく実行される。
<script src="https://gist.github.com/zaburo-ch/8c0bac865b2f9ddeb8f4.js"></script>
グローバル変数はヒープに取られるのに対して、
ローカル変数はスタックに積まれていく。
スタックのサイズは制限されていることが多く、
(bashならulimit -aで確認できる。8192KBだった)
bool型は1byteなので配列のサイズは10000001/1024≒9765KBとなり
スタックのサイズ制限を超えてしまうので、
メモリリミットより小さいがローカル変数として確保できない。

[参考]
<a href="http://homepage2.nifty.com/well/Variable.html" target="_blank" title="http://homepage2.nifty.com/well/Variable.html"><u>http://homepage2.nifty.com/well/Variable.html</u></a>
-----
EXTENDED BODY:

-----
EXCERPT:

-----
KEYWORDS:

-----
COMMENT:
AUTHOR: 
EMAIL: 
IP: zaq771a3920.zaq.ne.jp
URL: 
DATE: 06/17/2015 20:18:43
TITLE: No title
SECRET: 0
PASS: 74be16979710d4c4e7c6647856088456
new で確保すればいけますけどね。
この例の場合は C++ らしくやるなら vector 使うのがスマートかな。
-----
COMMENT:
AUTHOR: ZABURO
EMAIL: 
IP: KD182249246005.au-net.ne.jp
URL: 
DATE: 06/24/2015 12:11:30
TITLE: Re: No title
SECRET: 0
PASS: 74be16979710d4c4e7c6647856088456
&gt; new で確保すればいけますけどね。
&gt; この例の場合は C++ らしくやるなら vector 使うのがスマートかな。
コメントありがとうございます。
確かにvectorでやるのスマートですね！
後で追記させて頂こうと思います。
-----


--------
